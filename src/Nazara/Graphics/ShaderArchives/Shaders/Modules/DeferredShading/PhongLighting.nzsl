[nzsl_version("1.1")]
module DeferredShading.PhongLighting;

import DecodeNormal from DeferredShading.NormalEncoding;
import DirectionalLight, PointLight, SpotLight from Lighting.LightData;
import ViewerData from Engine.ViewerData;
import Engine.LightType;

import Lighting.Phong;
import Lighting.Shadow;

option Light: i32;
option EnableShadowMapping: bool;

[set(0), tag("PassData")]
external
{
	[binding(0), tag("ViewerData")] viewerData: uniform[ViewerData],
	[binding(1), tag("GBuffer0")] albedoMap: sampler2D[f32],
	[binding(2), tag("GBuffer1")] normalMap: sampler2D[f32],
	[binding(3), tag("DepthBuffer")] depthMap: sampler2D[f32]
}

[cond(Light == LightType.Directional)]
alias LightData = DirectionalLight;

[cond(Light == LightType.Point)]
alias LightData = PointLight;

[cond(Light == LightType.Spot)]
alias LightData = SpotLight;

[set(1), tag("LightData")]
external
{
	[binding(0), tag("LightData")] lightData: uniform[LightData]
}

struct FragIn
{
	[builtin(frag_coord)] fragcoord: vec4[f32]
}

struct FragOut
{
	[location(0)] color: vec4[f32]
}

[entry(frag)]
fn main(input: FragIn) -> FragOut
{
	let texCoords = input.fragcoord.xy * viewerData.invRenderTargetSize;

	let albedo = albedoMap.Sample(texCoords);
	let normal = DecodeNormal(normalMap.Sample(texCoords).rgb);
	let depth = depthMap.Sample(texCoords).r;

	let viewspace = vec4[f32](texCoords * 2.0 - vec2[f32](1.0, 1.0), depth, 1.0);
	let worldPos = viewerData.invViewProjMatrix * viewspace;
	let worldPos = worldPos.xyz / worldPos.w;

	let lightAmbient  = vec3[f32](0.0, 0.0, 0.0);
	let lightDiffuse  = vec3[f32](0.0, 0.0, 0.0);
	let lightSpecular = vec3[f32](0.0, 0.0, 0.0);

	let eyeVec = normalize(viewerData.eyePosition - worldPos);

	const shininess = 2.0;

	let light = lightData;
	const if (Light == LightType.Directional)
	{
		let result = Phong.ComputeDirectionalLight(light, eyeVec, normal, shininess);

		let shadowFactor = 1.0;

		lightAmbient += result.ambient;
		lightDiffuse += shadowFactor * result.diffuse;
		lightSpecular += shadowFactor * result.specular;
	}
	else if (Light == LightType.Point)
	{
		let result = Phong.ComputePointLight(light, eyeVec, normal, shininess, worldPos);

		let shadowFactor = 1.0;

		lightAmbient += result.ambient;
		lightDiffuse += shadowFactor * result.diffuse;
		lightSpecular += shadowFactor * result.specular;
	}
	else if (Light == LightType.Spot)
	{
		let result = Phong.ComputeSpotLight(light, eyeVec, normal, shininess, worldPos);

		let shadowFactor = 1.0;

		lightAmbient += result.ambient;
		lightDiffuse += shadowFactor * result.diffuse;
		lightSpecular += shadowFactor * result.specular;
	}

	let lightColor = lightAmbient + lightDiffuse + lightSpecular;

	let output: FragOut;
	output.color = albedo * vec4[f32](lightColor, 1.0);

	return output;
}

[cond(Light == LightType.Directional)]
struct VertIn
{
	[builtin(vertex_index)] vert_index: i32
}

[cond(Light != LightType.Directional)]
struct VertIn
{
	[location(0)] pos: vec3[f32]
}

struct VertOut
{
	[builtin(position)] position: vec4[f32]
}

const fullscreenTri = array[vec2[f32]](
	vec2[f32](-1.0, -3.0),
	vec2[f32](-1.0, 1.0),
	vec2[f32]( 3.0, 1.0)
);

[entry(vert)]
fn VertexShader(input: VertIn) -> VertOut
{
	let output: VertOut;

	const if (Light == LightType.Directional)
		output.position = vec4[f32](fullscreenTri[input.vert_index], 0.0, 1.0);

	const if (Light == LightType.Point)
		output.position = viewerData.viewProjMatrix * vec4[f32](lightData.position + input.pos * lightData.radius, 1.0);

	const if (Light == LightType.Spot)
		output.position = viewerData.viewProjMatrix * lightData.worldMatrix * vec4[f32](input.pos, 1.0); //< worldMatrix takes care of the radius

	return output;
}
