[nzsl_version("1.1")]
module DeferredShading.PhysicallyBasedLighting;

import DecodeNormal from DeferredShading.NormalEncoding;
import DirectionalLight, PointLight, SpotLight from Lighting.LightData;
import ViewerData from Engine.ViewerData;
import Pi from Math.Constants;
import Engine.LightType;

import Lighting.PhysicallyBased;
import Lighting.Shadow;

option Light: i32;
option EnableShadowMapping: bool;

[set(0), tag("PassData")]
external
{
	[binding(0), tag("ViewerData")] viewerData: uniform[ViewerData],
	[binding(1), tag("GBuffer0")] albedoMap: sampler2D[f32],
	[binding(2), tag("GBuffer1")] normalMap: sampler2D[f32],
	[binding(3), tag("DepthBuffer")] depthMap: sampler2D[f32]
}

[set(1), tag("LightData"), cond(Light == LightType.Directional)]
external
{
	[binding(0), tag("LightData")] lightData: uniform[DirectionalLight],
	[binding(1), tag("ShadowMap")] shadowMap: depth_sampler2D_array[f32],
}

[set(1), tag("LightData"), cond(Light == LightType.Point)]
external
{
	[binding(0), tag("LightData")] lightData: uniform[PointLight],
	[binding(1), tag("ShadowMap")] shadowMap: sampler_cube[f32],
}

[set(1), tag("LightData"), cond(Light == LightType.Spot)]
external
{
	[binding(0), tag("LightData")] lightData: uniform[SpotLight],
	[binding(1), tag("ShadowMap")] shadowMap: depth_sampler2D[f32],
}

struct FragIn
{
	[builtin(frag_coord)] fragcoord: vec4[f32]
}

struct FragOut
{
	[location(0)] color: vec4[f32]
}

[entry(frag)]
[early_fragment_tests(true)]
fn main(input: FragIn) -> FragOut
{
	let texCoords = input.fragcoord.xy * viewerData.invRenderTargetSize;

	let albedo = albedoMap.Sample(texCoords);
	let metalness = albedo.w;
	let albedo = albedo.rgb;

	let normal = normalMap.Sample(texCoords);
	let roughness = normal.w;
	let normal = DecodeNormal(normal.rgb);

	let depth = depthMap.Sample(texCoords).r;

	let viewspace = vec4[f32](texCoords * 2.0 - vec2[f32](1.0, 1.0), depth, 1.0);
	let worldPos = viewerData.invViewProjMatrix * viewspace;
	let worldPos = worldPos.xyz / worldPos.w;

	let lightRadiance  = vec3[f32](0.0, 0.0, 0.0);

	let eyeVec = normalize(viewerData.eyePosition - worldPos);

	let F0 = vec3[f32](0.04, 0.04, 0.04);
	F0 = lerp(F0, albedo, metalness.rrr);

	let albedoFactor = albedo / Pi;

	let light = lightData;
	const if (Light == LightType.Directional)
	{
		let result = PhysicallyBased.ComputeDirectionalLight(light, eyeVec, albedoFactor, F0, normal, metalness, roughness);

		let shadowFactor = 1.0;
		const if (EnableShadowMapping)
			shadowFactor = Shadow.ComputeDirectionalLightShadow(light, shadowMap, worldPos, result.lambert, viewerData.viewMatrix);

		lightRadiance += shadowFactor * result.radiance;
	}
	else if (Light == LightType.Point)
	{
		let result = PhysicallyBased.ComputePointLight(light, eyeVec, albedoFactor, F0, normal, metalness, roughness, worldPos);

		let shadowFactor = 1.0;
		const if (EnableShadowMapping)
			shadowFactor = Shadow.ComputePointLightShadow(light, shadowMap, result.dist, result.lightToWorldDir);

		lightRadiance += shadowFactor * result.radiance;
	}
	else if (Light == LightType.Spot)
	{
		let result = PhysicallyBased.ComputeSpotLight(light, eyeVec, albedoFactor, F0, normal, metalness, roughness, worldPos);
		const if (EnableShadowMapping)
			shadowFactor = Shadow.ComputeSpotLightShadow(light, shadowMap, worldPos, result.lambert);

		let shadowFactor = 1.0;

		lightRadiance += shadowFactor * result.radiance;
	}

	let ambient = (0.03).rrr * albedo;

	let finalColor = ambient + lightRadiance;
	finalColor = finalColor / (finalColor + vec3[f32](1.0, 1.0, 1.0));

	let output: FragOut;
	output.color = vec4[f32](finalColor, 1.0);

	return output;
}

[cond(Light == LightType.Directional)]
struct VertIn
{
	[builtin(vertex_index)] vert_index: i32
}

[cond(Light != LightType.Directional)]
struct VertIn
{
	[location(0)] pos: vec3[f32]
}

struct VertOut
{
	[builtin(position)] position: vec4[f32]
}

const fullscreenTri = array[vec2[f32]](
	vec2[f32](-1.0, -3.0),
	vec2[f32](-1.0, 1.0),
	vec2[f32]( 3.0, 1.0)
);

[entry(vert)]
fn VertexShader(input: VertIn) -> VertOut
{
	let output: VertOut;

	const if (Light == LightType.Directional)
		output.position = vec4[f32](fullscreenTri[input.vert_index], 0.0, 1.0);

	const if (Light == LightType.Point)
		output.position = viewerData.viewProjMatrix * vec4[f32](lightData.position + input.pos * lightData.radius, 1.0);

	const if (Light == LightType.Spot)
		output.position = viewerData.viewProjMatrix * lightData.worldMatrix * vec4[f32](input.pos, 1.0); //< worldMatrix takes care of the radius

	return output;
}
