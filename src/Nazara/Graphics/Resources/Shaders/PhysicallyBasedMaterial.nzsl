[nzsl_version("1.0")]
module PhysicallyBasedMaterial;

import InstanceData from Engine.InstanceData;
import LightData from Engine.LightData;
import ViewerData from Engine.ViewerData;

// Basic material options
option HasDiffuseTexture: bool = false;
option HasAlphaTexture: bool = false;
option AlphaTest: bool = false;

// Physically-based material options
option HasEmissiveTexture: bool = false;
option HasHeightTexture: bool = false;
option HasMetallicTexture: bool = false;
option HasNormalTexture: bool = false;
option HasRoughnessTexture: bool = false;
option HasSpecularTexture: bool = false;

// Billboard related options
option Billboard: bool = false;
option BillboardCenterLocation: i32 = -1;
option BillboardColorLocation: i32 = -1;
option BillboardSizeRotLocation: i32 = -1;

// Vertex declaration related options
option ColorLocation: i32 = -1;
option NormalLocation: i32 = -1;
option PosLocation: i32;
option TangentLocation: i32 = -1;
option UvLocation: i32 = -1;

const HasNormal = (NormalLocation >= 0);
const HasVertexColor = (ColorLocation >= 0);
const HasColor = (HasVertexColor || Billboard);
const HasTangent = (TangentLocation >= 0);
const HasUV = (UvLocation >= 0);
const HasNormalMapping = HasNormalTexture && HasNormal && HasTangent;

[layout(std140)]
struct MaterialSettings
{
	// BasicSettings
	AlphaThreshold: f32,
	DiffuseColor: vec4[f32],

	// PhongSettings
	AmbientColor: vec3[f32],
	SpecularColor: vec3[f32],
	Shininess: f32,
}

// TODO: Add enums
const DirectionalLight = 0;
const PointLight = 1;
const SpotLight = 2;

external
{
	[binding(0)] settings: uniform[MaterialSettings],
	[binding(1)] MaterialDiffuseMap: sampler2D[f32],
	[binding(2)] MaterialAlphaMap: sampler2D[f32],
	[binding(3)] TextureOverlay: sampler2D[f32],
	[binding(4)] instanceData: uniform[InstanceData],
	[binding(5)] viewerData: uniform[ViewerData],
	[binding(6)] lightData: uniform[LightData],
	[binding(7)] MaterialEmissiveMap: sampler2D[f32],
	[binding(8)] MaterialHeightMap: sampler2D[f32],
	[binding(9)] MaterialMetallicMap: sampler2D[f32],
	[binding(10)] MaterialNormalMap: sampler2D[f32],
	[binding(11)] MaterialRoughnessMap: sampler2D[f32],
	[binding(12)] MaterialSpecularMap: sampler2D[f32],
}

struct VertToFrag
{
	[location(0)] worldPos: vec3[f32],
	[location(1), cond(HasUV)] uv: vec2[f32],
	[location(2), cond(HasColor)] color: vec4[f32],
	[location(3), cond(HasNormal)] normal: vec3[f32],
	[location(4), cond(HasNormalMapping)] tbnMatrix: mat3[f32],
	[builtin(position)] position: vec4[f32],
}

// Fragment stage
const PI: f32 = 3.1415926535897932384626433832795;

fn DistributionGGX(N: vec3[f32], H: vec3[f32], roughness: f32) -> f32
{
	let a = roughness * roughness;
	let a2 = a * a;

	let NdotH = max(dot(N, H), 0.0);
	let NdotH2 = NdotH * NdotH;

	let num = a2;
	let denom = (NdotH2 * (a2 - 1.0) + 1.0);
	denom = PI * denom * denom;

	return num / denom;
}

fn GeometrySchlickGGX(NdotV: f32, roughness: f32) -> f32
{
	let r = (roughness + 1.0);
	let k = (r * r) / 8.0;

	let num = NdotV;
	let denom = NdotV * (1.0 - k) + k;

	return num / denom;
}

fn GeometrySmith(N: vec3[f32], V: vec3[f32], L: vec3[f32], roughness: f32) -> f32
{
	let NdotV = max(dot(N, V), 0.0);
	let NdotL = max(dot(N, L), 0.0);
	let ggx2  = GeometrySchlickGGX(NdotV, roughness);
	let ggx1  = GeometrySchlickGGX(NdotL, roughness);

	return ggx1 * ggx2;
}

fn FresnelSchlick(cosTheta: f32, F0: vec3[f32]) -> vec3[f32]
{
	// TODO: Clamp
    return F0 + (vec3[f32](1.0, 1.0, 1.0) - F0) * pow(min(max(1.0 - cosTheta, 0.0), 1.0), 5.0);
}  

struct FragOut
{
	[location(0)] RenderTarget0: vec4[f32]
}

[entry(frag)]
fn main(input: VertToFrag) -> FragOut
{
	let diffuseColor = settings.DiffuseColor;

	const if (HasUV)
		diffuseColor *= TextureOverlay.Sample(input.uv);

	const if (HasColor)
		diffuseColor *= input.color;

	const if (HasDiffuseTexture)
		diffuseColor *= MaterialDiffuseMap.Sample(input.uv);

	const if (HasAlphaTexture)
		diffuseColor.w *= MaterialAlphaMap.Sample(input.uv).x;

	const if (AlphaTest)
	{
		if (diffuseColor.w < settings.AlphaThreshold)
			discard;
	}

	const if (HasNormal)
	{
		let lightAmbient = vec3[f32](0.0, 0.0, 0.0);
		let lightDiffuse = vec3[f32](0.0, 0.0, 0.0);
		let lightSpecular = vec3[f32](0.0, 0.0, 0.0);

		let eyeVec = normalize(viewerData.eyePosition - input.worldPos);

		let normal: vec3[f32];
		const if (HasNormalMapping && false)
			normal = normalize(input.tbnMatrix * (MaterialNormalMap.Sample(input.uv).xyz * 2.0 - vec3[f32](1.0, 1.0, 1.0)));
		else
			normal = normalize(input.normal);

		let albedo = diffuseColor.xyz;
		let metallic: f32;
		let roughness: f32;

		const if (HasMetallicTexture)
			metallic = MaterialMetallicMap.Sample(input.uv).x;
		else
			metallic = 0.0;

		const if (HasRoughnessTexture)
			roughness = MaterialRoughnessMap.Sample(input.uv).x;
		else
			roughness = 0.8;

		let F0 = vec3[f32](0.04, 0.04, 0.04);
		F0 = albedo * metallic + F0 * (1.0 - metallic);

		for i in u32(0) -> lightData.lightCount
		{
			let light = lightData.lights[i];

			let lightAmbientFactor = light.factor.x;
			let lightDiffuseFactor = light.factor.y;

			// TODO: Add switch instruction
			if (light.type == DirectionalLight)
			{
				let lightDir = -light.parameter1.xyz;
				let H = normalize(lightDir + eyeVec);

				// cook-torrance brdf
				let NDF = DistributionGGX(normal, H, roughness);
				let G = GeometrySmith(normal, eyeVec, lightDir, roughness);
				let F = FresnelSchlick(max(dot(H, eyeVec), 0.0), F0);

				let kS = F;
				let kD = vec3[f32](1.0, 1.0, 1.0) - kS;
				kD *= 1.0 - metallic;

				let numerator = NDF * G * F;
				let denominator = 4.0 * max(dot(normal, eyeVec), 0.0) * max(dot(normal, lightDir), 0.0);
				let specular = numerator / max(denominator, 0.0001);

				let NdotL = max(dot(normal, -lightDir), 0.0);
				lightDiffuse += (kD * albedo / PI + specular) * light.color.rgb * NdotL;

				//lightDiffuse = specular;
			}
			else if (light.type == PointLight)
			{
				let lightPos = light.parameter1.xyz;
				let lightInvRadius = light.parameter1.w;

				let lightToPos = input.worldPos - lightPos;
				let dist = length(lightToPos);
				let lightToPosNorm = lightToPos / max(dist, 0.0001);

				let attenuationFactor = max(1.0 - dist * lightInvRadius, 0.0);

				lightAmbient += attenuationFactor * light.color.rgb * lightAmbientFactor * settings.AmbientColor;

				let lambert = max(dot(normal, -lightToPosNorm), 0.0);

				lightDiffuse += attenuationFactor * lambert * light.color.rgb * lightDiffuseFactor;

				let reflection = reflect(lightToPosNorm, normal);
				let specFactor = max(dot(reflection, eyeVec), 0.0);
				specFactor = pow(specFactor, settings.Shininess);

				lightSpecular += attenuationFactor * specFactor * light.color.rgb;
			}
			else if (light.type == SpotLight)
			{
				let lightPos = light.parameter1.xyz;
				let lightDir = light.parameter2.xyz;
				let lightInvRadius = light.parameter1.w;
				let lightInnerAngle = light.parameter3.x;
				let lightOuterAngle = light.parameter3.y;

				let lightToPos = input.worldPos - lightPos;
				let dist = length(lightToPos);
				let lightToPosNorm = lightToPos / max(dist, 0.0001);

				let curAngle = dot(lightDir, lightToPosNorm);
				let innerMinusOuterAngle = lightInnerAngle - lightOuterAngle;

				let attenuationFactor = max(1.0 - dist * lightInvRadius, 0.0);
				attenuationFactor *= max((curAngle - lightOuterAngle) / innerMinusOuterAngle, 0.0);			

				lightAmbient += attenuationFactor * light.color.rgb * lightAmbientFactor * settings.AmbientColor;

				let lambert = max(dot(normal, -lightToPosNorm), 0.0);

				lightDiffuse += attenuationFactor * lambert * light.color.rgb * lightDiffuseFactor;

				let reflection = reflect(lightToPosNorm, normal);
				let specFactor = max(dot(reflection, eyeVec), 0.0);
				specFactor = pow(specFactor, settings.Shininess);

				lightSpecular += attenuationFactor * specFactor * light.color.rgb;
			}
		}

		lightSpecular *= settings.SpecularColor;

		const if (HasSpecularTexture)
			lightSpecular *= MaterialSpecularMap.Sample(input.uv).rgb;

		let lightColor = lightAmbient + lightDiffuse + lightSpecular;

		let output: FragOut;
		output.RenderTarget0 = vec4[f32](lightColor, 1.0) * diffuseColor;
		return output;
	}
	else
	{
		let output: FragOut;
		output.RenderTarget0 = diffuseColor;
		return output;
	}
}

// Vertex stage
struct VertIn
{
	[location(PosLocation)] 
	pos: vec3[f32],

	[cond(HasVertexColor), location(ColorLocation)] 
	color: vec4[f32],

	[cond(HasUV), location(UvLocation)] 
	uv: vec2[f32],

	[cond(HasNormal), location(NormalLocation)]
	normal: vec3[f32],

	[cond(HasTangent), location(TangentLocation)]
	tangent: vec3[f32],

	[cond(Billboard), location(BillboardCenterLocation)]
	billboardCenter: vec3[f32],

	[cond(Billboard), location(BillboardSizeRotLocation)]
	billboardSizeRot: vec4[f32], //< width,height,sin,cos

	[cond(Billboard), location(BillboardColorLocation)]
	billboardColor: vec4[f32]
}

[entry(vert), cond(Billboard)]
fn billboardMain(input: VertIn) -> VertToFrag
{
	let size = input.billboardSizeRot.xy;
	let sinCos = input.billboardSizeRot.zw;

	let rotatedPosition = vec2[f32](
		input.pos.x * sinCos.y - input.pos.y * sinCos.x,
		input.pos.y * sinCos.y + input.pos.x * sinCos.x
	);
	rotatedPosition *= size;

	let cameraRight = vec3[f32](viewerData.viewMatrix[0][0], viewerData.viewMatrix[1][0], viewerData.viewMatrix[2][0]);
	let cameraUp = vec3[f32](viewerData.viewMatrix[0][1], viewerData.viewMatrix[1][1], viewerData.viewMatrix[2][1]);

	let vertexPos = input.billboardCenter;
	vertexPos += cameraRight * rotatedPosition.x;
	vertexPos += cameraUp * rotatedPosition.y;

	let output: VertToFrag;
	output.position = viewerData.viewProjMatrix * instanceData.worldMatrix * vec4[f32](vertexPos, 1.0);
	
	const if (HasColor)
		output.color = input.billboardColor;
	
	const if (HasUV)
		output.uv = input.pos.xy + vec2[f32](0.5, 0.5);

	return output;
}

[entry(vert), cond(!Billboard)]
fn main(input: VertIn) -> VertToFrag
{
	let worldPosition = instanceData.worldMatrix * vec4[f32](input.pos, 1.0);

	let output: VertToFrag;
	output.worldPos = worldPosition.xyz;
	output.position = viewerData.viewProjMatrix * worldPosition;

	let rotationMatrix = mat3[f32](instanceData.worldMatrix);

	const if (HasColor)
		output.color = input.color;

	const if (HasNormal)
		output.normal = rotationMatrix * input.normal;

	const if (HasUV)
		output.uv = input.uv;

	const if (HasNormalMapping)
	{
		let binormal = cross(input.normal, input.tangent);
		output.tbnMatrix[0] = normalize(rotationMatrix * input.tangent);
		output.tbnMatrix[1] = normalize(rotationMatrix * binormal);
		output.tbnMatrix[2] = normalize(rotationMatrix * input.normal);
	}

	return output;
}
